# Git分支与相关操作

## 一些基本概念和常用的操作命令

Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。

**Note** ：
>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。

**分支创建**  
使用命令` git branch branchname`即可实现

**分支切换**  
使用命令`git checkout branchname`  
**Note**：分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。


`git checkout -b newBranchName`  创建一个新分支newBranchName并切换到该分支

**查看项目分叉历史**

`git log --oneline --decorate --graph --all`

**分支的合并**  
假设需要合并`newBranchName`分支到`master`分支，这时候需要两步：
1. 检出到`master`分支，命令`git checkout master`
2. 将`newBranchName`分支合并到`master`分支，命令`git merge newBranchName`


**遇到冲突时的分支合并**  
有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。这时候Git合并的时候会产生冲突， Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并 （unmerged）状态的文件。

任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，用======将两个冲突版本的内容进行分割。

此时你需要你需要手动修改冲突部分的内容，然后对每个文件用`git add`命令将其标记为冲突已解决。

也可以使用图形化工具`git mergetool`来解决这些冲突。[见后文](todo)

**分支的删除**  
已经合并进来的分支可能已经没有用处了，所以就可以删掉了，命令为`git branch -d newBranchName`

有时候Git认为有一些原因不应该删除某个分支，从而而阻止对分支的删除，此时可以使用命令`git branch -D newBranchName`强制删除该分支

**显示分支列表**  
`git branch` 命令不加任何参数会显示当前所有分支的列表，并且再当前所在分支前面加一个`*`号


**其它常用的分支操作命令**
* `git branch -v ` 查看每一个分支的最后一次提交  
* ` git branch --merged` 查看哪些分支已经合并到当前分支
* `git branch --no-merged` 查看所有包含未合并工作的分支


## 分支开发工作流

**长期分支**  
因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些
特性分支合并入其他分支中。

许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者
测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如针对某个问题进行修复的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。

通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。

可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。

**特性分支**  
特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。

**远程分支**  

**推送**
当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别
人协作的内容推送到公开分支。

如果希望和别人一起在名为 `serverfix` 的分支上工作，你可以像推送第一个分支那样推送它。 运行 `git push (remote) (branch)`.

**跟踪分支**  


**拉取**  
当 `git fetch` 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 
然而，有一个命令叫作 `git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，`git pull` 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然
后尝试合并入那个远程分支。

由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些。

**删除远程分支**  
假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 `--delete` 选项的 `git push` 命令来删
除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：

> `git push origin --delete serverfix`

**变基**  
在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。

 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。

你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。
一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 `origin/master` 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。

**!!!不要对在你的仓库外有副本的分支执行变基。**
//todo: 这部分内容有点复杂，以后再说吧。。。





